package store

import (
	"io"
	"net"
	"os"
	"path/filepath"
	"sync"

	"github.com/Lofanmi/go-switch-hosts/contracts"
	"github.com/Lofanmi/go-switch-hosts/internal/gotil"
	log "github.com/sirupsen/logrus"
	"github.com/spf13/viper"
)

type HostsStore struct {
	configLoader contracts.HostsConfigLoader
	parser       contracts.Parser
	network      contracts.Network
	list         contracts.EntrySlice
	mu           *sync.RWMutex
	exit         bool
}

func NewHostsStore(configLoader contracts.HostsConfigLoader, parser contracts.Parser, network contracts.Network) contracts.HostsStore {
	store := &HostsStore{
		configLoader: configLoader,
		parser:       parser,
		network:      network,
		mu:           new(sync.RWMutex),
	}
	configLoader.OnChange(func(event contracts.ChangeEvent) { store.onChange(event) })
	return store
}

func (s *HostsStore) Init() {
	list := s.loadHosts()
	s.Save(list)
}

func (s *HostsStore) Save(list contracts.EntrySlice) {
	s.mu.Lock()
	s.list = list
	s.mu.Unlock()

	filename := gotil.EtcHostsFilename()
	f, err := os.OpenFile(filename, os.O_CREATE|os.O_TRUNC|os.O_RDWR, 0755)
	if err != nil {
		panic(err)
	}
	defer func() { _ = f.Close() }()
	_ = s.Write(f)
	if gotil.IsDevelopment() {
		_ = s.Write(os.Stdout)
	}
}

func (s *HostsStore) List() contracts.EntrySlice {
	s.mu.RLock()
	defer s.mu.RUnlock()

	n := len(s.list)
	result := make(contracts.EntrySlice, n)
	for i := 0; i < n; i++ {
		result[i] = s.list[i]
	}
	return result
}

func (s *HostsStore) Write(buf io.Writer) (err error) {
	log.Debug("[开始] 写入 hosts 文件")
	for _, e := range s.List() {
		if _, err = buf.Write([]byte(e.String() + "\n")); err != nil {
			return
		}
	}
	log.Debug("[结束] 写入 hosts 文件")
	return
}

func (s *HostsStore) onChange(event contracts.ChangeEvent) {
	tcpList, err := s.network.GetTCPConnectionList()
	if err != nil {
		log.Error(err)
	}

	newer := s.loadHosts()
	store := s.List()
	change, older := store.Diff(newer)
	if !change {
		return
	}
	s.Save(newer)
	if older == nil {
		return
	}
	older.Range(func(ip string) bool {
		log.WithField("IP", ip).Debugf("需要杀死 TCP 连接")
		netIP := net.ParseIP(ip)
		if netIP == nil {
			return true
		}
		if tcp := tcpList.FindByDstIP(netIP); tcp != nil {
			log.WithField("IP", ip).Debugf("发现存在 TCP 连接: %s", tcp)
			if err = s.network.KillTCPConnection(tcp); err != nil {
				log.Error(err)
			}
		}
		return true
	})
}

func (s *HostsStore) loadHosts() (list contracts.EntrySlice) {
	hostsFiles := viper.GetStringSlice("global.hosts")
	hostsDir := viper.GetString("global.hosts_dir")
	hostsDir = gotil.ParsePath(hostsDir)
	log.WithField("hostsFiles", hostsFiles).Debug("用户 hosts 文件列表")
	list = make(contracts.EntrySlice, 0)
	s.parser.Comment(&list, "----------------------------------------------------------------------------")
	s.parser.Comment(&list, "-------------- Auto generated by go-switch-hosts. DO NOT EDIT. -------------")
	s.parser.Comment(&list, "----------------------------------------------------------------------------")
	s.parser.Comment(&list, "---------------- https://github.com/Lofanmi/go-switch-hosts ----------------")
	s.parser.Comment(&list, "----------------------------------------------------------------------------")
	s.parser.EmptyLine(&list)
	for _, filename := range hostsFiles {
		filename = filepath.Join(hostsDir, filename+ext)
		log.WithField("filename", filename).Debugf("加载用户 hosts 文件")
		data, e := os.ReadFile(filename)
		if e != nil {
			continue
		}
		s.parser.Comment(&list, "----------------------------------------------------------------------------")
		s.parser.Comment(&list, ">>> "+filename)
		s.parser.Comment(&list, "----------------------------------------------------------------------------")
		s.parser.Parse(&list, string(data))
		s.parser.Comment(&list, "----------------------------------------------------------------------------")
		s.parser.Comment(&list, "<<< "+filename)
		s.parser.Comment(&list, "----------------------------------------------------------------------------")
		s.parser.EmptyLine(&list)
	}
	return
}

// func (s *HostsStore) WatchHosts(hostsDir string) (err error) {
// 	for !s.exit {
// 		var hostsWatcher *fsnotify.Watcher
// 		if hostsWatcher, err = fsnotify.NewWatcher(); err != nil {
// 			return
// 		}
// 		hostsDir, _ = filepath.EvalSymlinks(hostsDir)
// 		eventsWG := new(sync.WaitGroup)
// 		eventsWG.Add(1)
// 		go func() {
// 			defer eventsWG.Done()
// 			for {
// 				select {
// 				case event, ok := <-hostsWatcher.Events:
// 					if !ok {
// 						return // close(hostsWatcher.Events)
// 					}
// 					s.OnChangeFn(contracts.ChangeEvent{Type: contracts.ChangeTypeHosts, Event: event})
// 				case e, ok := <-hostsWatcher.Errors:
// 					if ok {
// 						log.Printf("hostsWatcher error: %v\n", e)
// 					}
// 					return
// 				}
// 			}
// 		}()
// 		_ = hostsWatcher.Add(hostsDir)
// 		eventsWG.Wait()
// 		_ = hostsWatcher.Close()
// 	}
// 	return
// }
